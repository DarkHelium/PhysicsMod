Code "Rail Physics Extended" by "DarkHelium"
//
//  #include "Reflection" noemit
//
//  #lib "Reflection"
//  #lib "Player"
//  #lib "DeltaTime"
//  #lib "GameMode"
//  #lib "Globals"
//  #lib "HMM"
//  #lib "Lua"
//  #lib "MathHelpers"
//  #lib "Memory"
//  #lib "VectorHelpers"
//
//  using System.IO;

static bool isLoaded = false;
static string directory;
//
{
    // Initialize mod directory
    if (!isLoaded)
    {
        directory = Path.Combine(Directory.GetCurrentDirectory(), "Mods", "Physics");
        isLoaded = true;
    }

    // Adjust rail-related parameters (example property names)
    RFL_SET_PARAM(Player, modePackage.grind.acceleForce, 6f);
    RFL_SET_PARAM(Player, modePackage.grind.deceleForce, 4f);
    RFL_SET_PARAM(Player, modePackage.grind.limitSpeedMin, 2f);
    RFL_SET_PARAM(Player, modePackage.grind.limitSpeedMax, 30f);

    // Momentum-Based Rail Switching
    if (Player.Status.IsGrinding() && Player.Input.IsPressed(Player.InputActionType.PlayerRailSwitch))
    {
        var kinematics = Player.Kinematics.Get();
        if (kinematics == null) return;
        kinematics->Velocity += Player.Kinematics.GetForward() * 0.5f;
    }

    // Optional slope-based logic
    if (Player.Status.IsGrinding())
    {
        var kinematics = Player.Kinematics.Get();
        if (kinematics == null) return;

        float slopeFactor = Vector3.Dot(Player.Kinematics.GetForward(), Vector3.UnitY);
        float slopeMultiplier = 0.01f;

        var currentVelocity = kinematics->Velocity;
        float currentSpeed = currentVelocity.Length();
        var direction = currentVelocity.Normalized();

        float desiredSpeed = currentSpeed;
        if (slopeFactor > 0)      // Uphill
        {
            desiredSpeed -= currentSpeed * slopeFactor * slopeMultiplier;
        }
        else if (slopeFactor < 0) // Downhill
        {
            desiredSpeed += currentSpeed * -slopeFactor * slopeMultiplier;
        }

        float newSpeed = MathHelpers.Lerp(currentSpeed, desiredSpeed, 0.1f);
        kinematics->Velocity = direction * newSpeed;
    }
}


Code "Sonic - Jump and Gravity Rebalance" by "DarkHelium"
//
//  #include "Reflection" noemit
//
//  #lib "Reflection"
//  #lib "Player"
//  #lib "DeltaTime"
//  #lib "GameMode"
//  #lib "Globals"
//  #lib "HMM"
//  #lib "Lua"
//  #lib "MathHelpers"
//  #lib "Memory"
//  #lib "VectorHelpers"
//
//  using System.IO;

static bool isLoaded = false;
static string directory;
//
{
    // Initialize mod directory
    if (!isLoaded)
    {
        directory = Path.Combine(Directory.GetCurrentDirectory(), "Mods", "Physics");
        isLoaded = true;
    }

    // Adjust jump, gravity, and terminal velocity
    RFL_SET_PARAM(Player, modePackage.jump.jumpSpeed, 12.0f);
    RFL_SET_PARAM(Player, modePackage.jump.gravity, 6.0f);
    RFL_SET_PARAM(Player, modePackage.jump.terminalVelocity, -30.0f);

    // Momentum-based jump physics on inclines
    if (Player.Status.IsGrounded() && Player.Input.IsPressed(Player.InputActionType.PlayerJump))
    {
        var kinematics = Player.Kinematics.Get();
        if (kinematics == null) return;

        float slopeAngle = kinematics->FloorAngle;
        float inclineFactor = 1.0f + (slopeAngle / 45.0f) * 0.2f;
        kinematics->Velocity.y += 1.0f * inclineFactor;
    }
}


Code "Running Physics" by "DarkHelium"
//
//  #include "Reflection" noemit
//
//  #lib "Reflection"
//  #lib "Player"
//  #lib "DeltaTime"
//  #lib "GameMode"
//  #lib "Globals"
//  #lib "HMM"
//  #lib "Lua"
//  #lib "MathHelpers"
//  #lib "Memory"
//  #lib "VectorHelpers"
//
//  using System.IO;

static bool isLoaded = false;
static string directory;
//
{
    // Initialize mod directory
    if (!isLoaded)
    {
        directory = Path.Combine(Directory.GetCurrentDirectory(), "Mods", "CustomPhysicsMod");
        isLoaded = true;
    }

    // Basic run parameters
    RFL_SET_PARAM(Player, modePackage.run.runSpeed, 20f);
    RFL_SET_PARAM(Player, modePackage.run.acceleForce, 4f);
    RFL_SET_PARAM(Player, modePackage.run.deceleForce, 2f);

    // Optional slope-based logic
    if (Player.Status.IsGrounded())
    {
        var kinematics = Player.Kinematics.Get();
        if (kinematics == null) return;

        var currentVelocity = kinematics->Velocity;
        float currentSpeed = currentVelocity.Length();
        var direction = currentVelocity.Normalized();

        float slopeFactor = Vector3.Dot(Player.Kinematics.GetForward(), Vector3.UnitY);
        float slopeMultiplier = 0.01f;

        float desiredSpeed = currentSpeed;
        if (slopeFactor > 0)      // Uphill
        {
            desiredSpeed -= currentSpeed * slopeFactor * slopeMultiplier;
        }
        else if (slopeFactor < 0) // Downhill
        {
            desiredSpeed += currentSpeed * -slopeFactor * slopeMultiplier;
        }

        float newSpeed = MathHelpers.Lerp(currentSpeed, desiredSpeed, 0.1f);
        kinematics->Velocity = direction * newSpeed;
    }
}
